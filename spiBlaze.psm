counter_low 	equ		s0;
counter_mid	equ		s1;
counter_high 	equ		s2;
var_out		equ		s3;
shift_io	equ		s4;
shift_counter	equ		s5;
data_in_high	equ		s6;
data_in_low	equ		s7;
memory_cnt	equ		s8;
xy		equ		s9;

data_out_high	equ		sa;
data_out_low	equ		sb;

xDataHigh	equ		0x02;
xDataLow	equ		0x01;
yDataHigh	equ		0x20;
yDataLow	equ		0x10;

ioPort		equ		0x00;

busy_mask	equ		0x10;
miso_masl	equ		0x20;

cs_true		equ		0x01;
Nclk_Ndin	equ		0x00;
Nclk_din	equ		0x04;
clk_Ndin	equ		0x02;
clk_din		equ		0x06;


readX		equ		0x93;
readY		equ		0xd3;
;------------------------------------------- MAIN -------------------------------------------------
init:
	load 	memory_cnt,	0x00;
	load	var_out,	cs_true;	begin situation
	out	var_out,	ioPort;		Set csN high
	load 	xy,		0x00;		0 => read X, 1 => read Y

read:
	test 	xy,		0x10;
	call 	Z,		setX;
	call 	NZ,		setY;
	load	data_out_high,	0x00;
	load	data_out_low,	0x00;
	load	data_in_high,	0x00;
	load	data_in_low,	0x00;
	load 	shift_counter,	0xf8; 		Counter to count 8 bits
	load	var_out,	Nclk_Ndin;
	out	var_out,	ioPort;		Set dclk low and din MOSI low
shift:
	sl0	shift_io;			shift MOSI register	
	call 	C,		setMOSI;
	call 	NC,		clrMOSI;
	add	shift_counter,	0x01;
	jump	NC,		shift;
busy:	
	load 	var_out,	clk_Ndin;		
	out	var_out,	ioPort;		set dclk high
	call 	delay;
	load 	var_out,	Nclk_Ndin;		
	out	var_out,	ioPort;		set dclk low
	call 	delay;
	in	shift_io,	ioPort;
	test	shift_io,	busy_mask;
	jump	Z,		busy;
	load 	shift_counter,	0xf4; 
data_in:
	load	var_out,	clk_Ndin;
	out	var_out,	ioPort;		Set dclk high
	call 	delay;	
	in	shift_io,	ioPort;
	rl	shift_io;
	rl 	shift_io;
	rl	shift_io;			shift miso bit in carry
	sla	data_in_low;			shift carry in data0 and data7 in carry
	sla	data_in_high;			shift carry in data8
	load	var_out,	Nclk_Ndin;
	out	var_out,	ioPort;		Set dclk low
	call 	delay;
	add	shift_counter,	0x01;
	jump	NC,		data_in;	
	load 	var_out,	cs_true;	set CS high		
	out	var_out,	ioPort;

	load 	shift_io,	memory_cnt;	---------------- STOR VALUES -------------
	or	shift_io,	xy;
	store	data_in_high, 	(shift_io);
	add	shift_io,	0x01;
	store	data_in_low, 	(shift_io);
	
	load 	counter_low,	memory_cnt
	and	counter_low,	xy;		count_low contains memory location of next memory place
	load	counter_high,	counter_low;
	add	counter_high,	0x10;
;	jump 	calc_avg;
load_data:
	fetch	data_in_high, 	(counter_low);
	add	counter_low,	0x01;
	fetch	data_in_low, 	(counter_low);
	add 	counter_low,	0x01;
calc_avg:
	add	data_out_low,data_in_low;
	addc	data_out_high,data_in_high;	

	
	test 	counter_low,	counter_high;
	jump 	Z,		load_data; 
	
	sr0	data_out_high;
	sra	data_out_low; /2
	sr0	data_out_high;
	sra	data_out_low; /4
	sr0	data_out_high;
	sra	data_out_low; /8
	
	test 	xy,		0x10;
	call 	NZ,		memadd;

	xor  	xy,		0x10;	switch x<->y read
	call 	delay;
	jump 	read;


;--------------------------------------- FUNCTIONS ---------------------------------------------
	
delay:
	load	counter_low,	0x00;
	load	counter_mid,	0x00;
	load	counter_high,	0x00;
delay_inner:
	add 	counter_low,	0xff;		SHOULD be 0x01 @ 125MHz
	jump 	NC,		delay_inner;
	add	counter_mid,	0x41;		SHOULD be 0x01 @ 125MHz
	jump 	NC,		delay_inner;
	add	counter_high,	0x01;
	test	counter_high,	0x02; 
	jump 	NC,		delay_inner;
	ret;
setMOSI:
	load 	var_out,	Nclk_din;		
	out	var_out,	ioPort;
	call 	delay;
	load 	var_out,	clk_din;		
	out	var_out,	ioPort;
	call 	delay;
	ret;
	
clrMOSI:
	load 	var_out,	Nclk_Ndin;		
	out	var_out,	ioPort;
	call 	delay;
	load 	var_out,	clk_Ndin;		
	out	var_out,	ioPort;
	call 	delay;
	ret;
setX:
	out	data_out_high,	yDataHigh;	output average y data and prepare to read x data
	out	data_out_low,	yDataLow;
	load	shift_io,	readX;
	ret;
setY:
	out	data_out_high,	xDataHigh;	output average x data and prepare to read y data
	out	data_out_low,	xDataLow;
	load	shift_io,	readY;
	ret;
memadd:
	add	memory_cnt,	0x02;
	test	memory_cnt,	0x10;
	call 	NZ,		memclr;
	ret;
memclr:
	load	memory_cnt,	0x00;
	ret;
end:
